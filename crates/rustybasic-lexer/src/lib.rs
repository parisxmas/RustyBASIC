use logos::Logos;
use rustybasic_common::Span;

/// Token type for QBASIC dialect, generated by logos.
/// Keywords are case-insensitive via `(?i:...)` patterns.
/// Compound keywords (END IF, EXIT FOR, etc.) are handled in the parser
/// as pairs of simple tokens, to avoid DFA conflicts in logos.
#[derive(Logos, Debug, Clone, PartialEq)]
#[logos(skip r"[ \t]+")]
pub enum TokenKind {
    // ── Line structure ──────────────────────────────────────
    #[regex(r"\n|\r\n")]
    Newline,

    // ── Comments ────────────────────────────────────────────
    #[regex(r"(?i:REM)[^\n\r]*")]
    Rem,

    #[regex(r"'[^\n\r]*")]
    Comment,

    // ── QBASIC keywords ─────────────────────────────────────
    #[regex(r"(?i:LET)")]
    Let,
    #[regex(r"(?i:PRINT)")]
    Print,
    #[regex(r"(?i:INPUT)")]
    Input,
    #[regex(r"(?i:IF)")]
    If,
    #[regex(r"(?i:THEN)")]
    Then,
    #[regex(r"(?i:ELSE)")]
    Else,
    #[regex(r"(?i:ELSEIF)")]
    ElseIf,
    #[regex(r"(?i:FOR)")]
    For,
    #[regex(r"(?i:TO)")]
    To,
    #[regex(r"(?i:STEP)")]
    Step,
    #[regex(r"(?i:NEXT)")]
    Next,
    #[regex(r"(?i:GOTO)")]
    Goto,
    #[regex(r"(?i:GOSUB)")]
    Gosub,
    #[regex(r"(?i:RETURN)")]
    Return,
    #[regex(r"(?i:END)")]
    End,
    #[regex(r"(?i:DIM)")]
    Dim,
    #[regex(r"(?i:REDIM)")]
    ReDim,
    #[regex(r"(?i:AS)")]
    As,
    #[regex(r"(?i:CONST)")]
    Const,

    // ── Procedures ──────────────────────────────────────────
    #[regex(r"(?i:SUB)")]
    Sub,
    #[regex(r"(?i:FUNCTION)")]
    Function,
    #[regex(r"(?i:DECLARE)")]
    Declare,
    #[regex(r"(?i:CALL)")]
    Call,
    #[regex(r"(?i:EXIT)")]
    Exit,
    #[regex(r"(?i:SHARED)")]
    Shared,
    #[regex(r"(?i:STATIC)")]
    Static,
    #[regex(r"(?i:BYVAL)")]
    ByVal,
    #[regex(r"(?i:BYREF)")]
    ByRef,

    // ── Control flow ────────────────────────────────────────
    #[regex(r"(?i:DO)")]
    Do,
    #[regex(r"(?i:LOOP)")]
    Loop,
    #[regex(r"(?i:WHILE)")]
    While,
    #[regex(r"(?i:WEND)")]
    Wend,
    #[regex(r"(?i:UNTIL)")]
    Until,
    #[regex(r"(?i:SELECT)")]
    Select,
    #[regex(r"(?i:CASE)")]
    Case,

    // ── Logical / Bitwise ───────────────────────────────────
    #[regex(r"(?i:AND)")]
    And,
    #[regex(r"(?i:OR)")]
    Or,
    #[regex(r"(?i:NOT)")]
    Not,
    #[regex(r"(?i:XOR)")]
    Xor,
    #[regex(r"(?i:MOD)")]
    Mod,

    // ── Type keywords ───────────────────────────────────────
    #[regex(r"(?i:INTEGER)")]
    IntegerType,
    #[regex(r"(?i:LONG)")]
    LongType,
    #[regex(r"(?i:SINGLE)")]
    SingleType,
    #[regex(r"(?i:DOUBLE)")]
    DoubleType,
    #[regex(r"(?i:STRING)")]
    StringType,

    // ── Hardware keywords (ESP32 extensions) ────────────────
    #[regex(r"(?i:GPIO\.SET)")]
    GpioSet,
    #[regex(r"(?i:GPIO\.READ)")]
    GpioRead,
    #[regex(r"(?i:GPIO\.MODE)")]
    GpioMode,
    #[regex(r"(?i:I2C\.SETUP)")]
    I2cSetup,
    #[regex(r"(?i:I2C\.WRITE)")]
    I2cWrite,
    #[regex(r"(?i:I2C\.READ)")]
    I2cRead,
    #[regex(r"(?i:SPI\.SETUP)")]
    SpiSetup,
    #[regex(r"(?i:SPI\.TRANSFER)")]
    SpiTransfer,
    #[regex(r"(?i:WIFI\.CONNECT)")]
    WifiConnect,
    #[regex(r"(?i:WIFI\.STATUS)")]
    WifiStatus,
    #[regex(r"(?i:WIFI\.DISCONNECT)")]
    WifiDisconnect,
    #[regex(r"(?i:DELAY)")]
    Delay,
    #[regex(r"(?i:ADC\.READ)")]
    AdcRead,
    #[regex(r"(?i:PWM\.SETUP)")]
    PwmSetup,
    #[regex(r"(?i:PWM\.DUTY)")]
    PwmDuty,
    #[regex(r"(?i:UART\.SETUP)")]
    UartSetup,
    #[regex(r"(?i:UART\.WRITE)")]
    UartWrite,
    #[regex(r"(?i:UART\.READ)")]
    UartRead,
    #[regex(r"(?i:TIMER\.START)")]
    TimerStart,
    #[regex(r"(?i:TIMER\.ELAPSED)")]
    TimerElapsed,
    #[regex(r"(?i:HTTP\.GET)")]
    HttpGet,
    #[regex(r"(?i:HTTP\.POST)")]
    HttpPost,
    #[regex(r"(?i:NVS\.WRITE)")]
    NvsWrite,
    #[regex(r"(?i:NVS\.READ)")]
    NvsRead,
    #[regex(r"(?i:MQTT\.CONNECT)")]
    MqttConnect,
    #[regex(r"(?i:MQTT\.DISCONNECT)")]
    MqttDisconnect,
    #[regex(r"(?i:MQTT\.PUBLISH)")]
    MqttPublish,
    #[regex(r"(?i:MQTT\.SUBSCRIBE)")]
    MqttSubscribe,
    #[regex(r"(?i:MQTT\.RECEIVE)")]
    MqttReceive,
    #[regex(r"(?i:BLE\.INIT)")]
    BleInit,
    #[regex(r"(?i:BLE\.ADVERTISE)")]
    BleAdvertise,
    #[regex(r"(?i:BLE\.SCAN)")]
    BleScan,
    #[regex(r"(?i:BLE\.SEND)")]
    BleSend,
    #[regex(r"(?i:BLE\.RECEIVE)")]
    BleReceive,
    #[regex(r"(?i:JSON\.GET)")]
    JsonGet,
    #[regex(r"(?i:JSON\.SET)")]
    JsonSet,
    #[regex(r"(?i:JSON\.COUNT)")]
    JsonCount,
    #[regex(r"(?i:LED\.SETUP)")]
    LedSetup,
    #[regex(r"(?i:LED\.SET)")]
    LedSet,
    #[regex(r"(?i:LED\.SHOW)")]
    LedShow,
    #[regex(r"(?i:LED\.CLEAR)")]
    LedClear,
    #[regex(r"(?i:DEEPSLEEP)")]
    DeepSleep,
    #[regex(r"(?i:ESPNOW\.INIT)")]
    EspnowInit,
    #[regex(r"(?i:ESPNOW\.SEND)")]
    EspnowSend,
    #[regex(r"(?i:ESPNOW\.RECEIVE)")]
    EspnowReceive,

    // ── DATA/READ/RESTORE ─────────────────────────────────
    #[regex(r"(?i:DATA)")]
    Data,
    #[regex(r"(?i:READ)")]
    Read,
    #[regex(r"(?i:RESTORE)")]
    Restore,

    // ── Classic BASIC extensions ─────────────────────────
    #[regex(r"(?i:ON)")]
    On,
    #[regex(r"(?i:SWAP)")]
    Swap,
    #[regex(r"(?i:DEF)")]
    Def,
    #[regex(r"(?i:RANDOMIZE)")]
    Randomize,
    #[regex(r"(?i:USING)")]
    Using,
    #[regex(r"(?i:ERROR)")]
    Error,

    // ── New hardware keywords (ESP32 extensions) ─────────
    #[regex(r"(?i:TOUCH\.READ)")]
    TouchRead,
    #[regex(r"(?i:SERVO\.ATTACH)")]
    ServoAttach,
    #[regex(r"(?i:SERVO\.WRITE)")]
    ServoWrite,
    #[regex(r"(?i:TONE)")]
    Tone,
    #[regex(r"(?i:IRQ\.ATTACH)")]
    IrqAttach,
    #[regex(r"(?i:IRQ\.DETACH)")]
    IrqDetach,
    #[regex(r"(?i:TEMP\.READ)")]
    TempRead,
    #[regex(r"(?i:OTA\.UPDATE)")]
    OtaUpdate,
    #[regex(r"(?i:OLED\.INIT)")]
    OledInit,
    #[regex(r"(?i:OLED\.PRINT)")]
    OledPrint,
    #[regex(r"(?i:OLED\.PIXEL)")]
    OledPixel,
    #[regex(r"(?i:OLED\.LINE)")]
    OledLine,
    #[regex(r"(?i:OLED\.CLEAR)")]
    OledClear,
    #[regex(r"(?i:OLED\.SHOW)")]
    OledShow,
    #[regex(r"(?i:LCD\.INIT)")]
    LcdInit,
    #[regex(r"(?i:LCD\.PRINT)")]
    LcdPrint,
    #[regex(r"(?i:LCD\.CLEAR)")]
    LcdClear,
    #[regex(r"(?i:LCD\.POS)")]
    LcdPos,
    #[regex(r"(?i:UDP\.INIT)")]
    UdpInit,
    #[regex(r"(?i:UDP\.SEND)")]
    UdpSend,
    #[regex(r"(?i:UDP\.RECEIVE)")]
    UdpReceive,

    // ── New hardware keywords (ESP32 extensions, phase 2) ─
    #[regex(r"(?i:NTP\.SYNC)")]
    NtpSync,
    #[regex(r"(?i:NTP\.TIME\$)")]
    NtpTime,
    #[regex(r"(?i:NTP\.EPOCH)")]
    NtpEpoch,
    #[regex(r"(?i:FILE\.OPEN)")]
    FileOpen,
    #[regex(r"(?i:FILE\.WRITE)")]
    FileWrite,
    #[regex(r"(?i:FILE\.READ\$)")]
    FileReadStr,
    #[regex(r"(?i:FILE\.CLOSE)")]
    FileClose,
    #[regex(r"(?i:FILE\.DELETE)")]
    FileDelete,
    #[regex(r"(?i:FILE\.EXISTS)")]
    FileExists,
    #[regex(r"(?i:WS\.CONNECT)")]
    WsConnect,
    #[regex(r"(?i:WS\.SEND)")]
    WsSend,
    #[regex(r"(?i:WS\.RECEIVE\$)")]
    WsReceiveStr,
    #[regex(r"(?i:WS\.CLOSE)")]
    WsClose,
    #[regex(r"(?i:TCP\.LISTEN)")]
    TcpListen,
    #[regex(r"(?i:TCP\.ACCEPT)")]
    TcpAccept,
    #[regex(r"(?i:TCP\.SEND)")]
    TcpSend,
    #[regex(r"(?i:TCP\.RECEIVE\$)")]
    TcpReceiveStr,
    #[regex(r"(?i:TCP\.CLOSE)")]
    TcpClose,
    #[regex(r"(?i:WDT\.ENABLE)")]
    WdtEnable,
    #[regex(r"(?i:WDT\.FEED)")]
    WdtFeed,
    #[regex(r"(?i:WDT\.DISABLE)")]
    WdtDisable,
    #[regex(r"(?i:HTTPS\.GET\$)")]
    HttpsGet,
    #[regex(r"(?i:HTTPS\.POST\$)")]
    HttpsPost,
    #[regex(r"(?i:I2S\.INIT)")]
    I2sInit,
    #[regex(r"(?i:I2S\.WRITE)")]
    I2sWrite,
    #[regex(r"(?i:I2S\.STOP)")]
    I2sStop,

    // ── New language features ─────────────────────────────
    #[regex(r"(?i:ASSERT)")]
    Assert,
    #[regex(r"(?i:ENUM)")]
    Enum,
    #[regex(r"(?i:EACH)")]
    Each,
    #[regex(r"(?i:IN)")]
    In,
    #[regex(r"(?i:TRY)")]
    Try,
    #[regex(r"(?i:CATCH)")]
    Catch,
    #[regex(r"(?i:LAMBDA)")]
    Lambda,
    #[regex(r"(?i:TASK)")]
    Task,
    #[regex(r"(?i:MACHINE)")]
    Machine,
    // STATE is not a keyword — it's handled as Ident("STATE") inside MACHINE blocks
    #[regex(r"(?i:MODULE)")]
    Module,
    #[token("=>")]
    FatArrow,

    // ── Literals ────────────────────────────────────────────
    #[regex(r"[0-9]+\.[0-9]*([eE][+-]?[0-9]+)?", |lex| lex.slice().parse::<f32>().ok())]
    #[regex(r"\.[0-9]+([eE][+-]?[0-9]+)?", |lex| lex.slice().parse::<f32>().ok())]
    FloatLiteral(f32),

    #[regex(r"[0-9]+", priority = 5, callback = |lex| lex.slice().parse::<i32>().ok())]
    IntLiteral(i32),

    #[regex(r#""[^"]*""#, |lex| {
        let s = lex.slice();
        Some(s[1..s.len()-1].to_string())
    })]
    StringLiteral(String),

    #[regex(r#"\$"[^"]*""#, |lex| {
        let s = lex.slice();
        Some(s[2..s.len()-1].to_string())
    })]
    InterpolatedString(String),

    // ── Identifiers ─────────────────────────────────────────
    // String variable/function (ends with $)
    #[regex(r"[a-zA-Z_][a-zA-Z0-9_.]*\$", |lex| lex.slice().to_uppercase())]
    StringIdent(String),

    // Integer variable (ends with %)
    #[regex(r"[a-zA-Z_][a-zA-Z0-9_.]*%", |lex| lex.slice().to_uppercase())]
    IntIdent(String),

    // Long variable (ends with &)
    #[regex(r"[a-zA-Z_][a-zA-Z0-9_.]*&", |lex| lex.slice().to_uppercase())]
    LongIdent(String),

    // Single variable (ends with !)
    #[regex(r"[a-zA-Z_][a-zA-Z0-9_.]*!", |lex| lex.slice().to_uppercase())]
    SingleIdent(String),

    // Double variable (ends with #)
    #[regex(r"[a-zA-Z_][a-zA-Z0-9_.]*#", |lex| lex.slice().to_uppercase())]
    DoubleIdent(String),

    // Regular identifier (includes dots for struct field access: origin.x)
    #[regex(r"[a-zA-Z_][a-zA-Z0-9_.]*", callback = |lex| lex.slice().to_uppercase())]
    Ident(String),

    // ── Operators ───────────────────────────────────────────
    #[token("+")]
    Plus,
    #[token("-")]
    Minus,
    #[token("*")]
    Star,
    #[token("/")]
    Slash,
    #[token("\\")]
    Backslash, // integer division in QBASIC
    #[token("^")]
    Caret,
    #[token("=")]
    Eq,
    #[token("<>")]
    Neq,
    #[token("<")]
    Lt,
    #[token(">")]
    Gt,
    #[token("<=")]
    Le,
    #[token(">=")]
    Ge,

    // ── Punctuation ─────────────────────────────────────────
    #[token("(")]
    LParen,
    #[token(")")]
    RParen,
    #[token(",")]
    Comma,
    #[token(";")]
    Semicolon,
    #[token(":")]
    Colon,
}

impl std::fmt::Display for TokenKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TokenKind::Newline => write!(f, "newline"),
            TokenKind::Rem => write!(f, "REM"),
            TokenKind::Comment => write!(f, "'comment"),
            TokenKind::Let => write!(f, "LET"),
            TokenKind::Print => write!(f, "PRINT"),
            TokenKind::Input => write!(f, "INPUT"),
            TokenKind::If => write!(f, "IF"),
            TokenKind::Then => write!(f, "THEN"),
            TokenKind::Else => write!(f, "ELSE"),
            TokenKind::ElseIf => write!(f, "ELSEIF"),
            TokenKind::For => write!(f, "FOR"),
            TokenKind::To => write!(f, "TO"),
            TokenKind::Step => write!(f, "STEP"),
            TokenKind::Next => write!(f, "NEXT"),
            TokenKind::Goto => write!(f, "GOTO"),
            TokenKind::Gosub => write!(f, "GOSUB"),
            TokenKind::Return => write!(f, "RETURN"),
            TokenKind::End => write!(f, "END"),
            TokenKind::Dim => write!(f, "DIM"),
            TokenKind::ReDim => write!(f, "REDIM"),
            TokenKind::As => write!(f, "AS"),
            TokenKind::Const => write!(f, "CONST"),
            TokenKind::Sub => write!(f, "SUB"),
            TokenKind::Function => write!(f, "FUNCTION"),
            TokenKind::Declare => write!(f, "DECLARE"),
            TokenKind::Call => write!(f, "CALL"),
            TokenKind::Exit => write!(f, "EXIT"),
            TokenKind::Shared => write!(f, "SHARED"),
            TokenKind::Static => write!(f, "STATIC"),
            TokenKind::ByVal => write!(f, "BYVAL"),
            TokenKind::ByRef => write!(f, "BYREF"),
            TokenKind::Do => write!(f, "DO"),
            TokenKind::Loop => write!(f, "LOOP"),
            TokenKind::While => write!(f, "WHILE"),
            TokenKind::Wend => write!(f, "WEND"),
            TokenKind::Until => write!(f, "UNTIL"),
            TokenKind::Select => write!(f, "SELECT"),
            TokenKind::Case => write!(f, "CASE"),
            TokenKind::And => write!(f, "AND"),
            TokenKind::Or => write!(f, "OR"),
            TokenKind::Not => write!(f, "NOT"),
            TokenKind::Xor => write!(f, "XOR"),
            TokenKind::Mod => write!(f, "MOD"),
            TokenKind::IntegerType => write!(f, "INTEGER"),
            TokenKind::LongType => write!(f, "LONG"),
            TokenKind::SingleType => write!(f, "SINGLE"),
            TokenKind::DoubleType => write!(f, "DOUBLE"),
            TokenKind::StringType => write!(f, "STRING"),
            TokenKind::GpioSet => write!(f, "GPIO.SET"),
            TokenKind::GpioRead => write!(f, "GPIO.READ"),
            TokenKind::GpioMode => write!(f, "GPIO.MODE"),
            TokenKind::I2cSetup => write!(f, "I2C.SETUP"),
            TokenKind::I2cWrite => write!(f, "I2C.WRITE"),
            TokenKind::I2cRead => write!(f, "I2C.READ"),
            TokenKind::SpiSetup => write!(f, "SPI.SETUP"),
            TokenKind::SpiTransfer => write!(f, "SPI.TRANSFER"),
            TokenKind::WifiConnect => write!(f, "WIFI.CONNECT"),
            TokenKind::WifiStatus => write!(f, "WIFI.STATUS"),
            TokenKind::WifiDisconnect => write!(f, "WIFI.DISCONNECT"),
            TokenKind::Delay => write!(f, "DELAY"),
            TokenKind::AdcRead => write!(f, "ADC.READ"),
            TokenKind::PwmSetup => write!(f, "PWM.SETUP"),
            TokenKind::PwmDuty => write!(f, "PWM.DUTY"),
            TokenKind::UartSetup => write!(f, "UART.SETUP"),
            TokenKind::UartWrite => write!(f, "UART.WRITE"),
            TokenKind::UartRead => write!(f, "UART.READ"),
            TokenKind::TimerStart => write!(f, "TIMER.START"),
            TokenKind::TimerElapsed => write!(f, "TIMER.ELAPSED"),
            TokenKind::HttpGet => write!(f, "HTTP.GET"),
            TokenKind::HttpPost => write!(f, "HTTP.POST"),
            TokenKind::NvsWrite => write!(f, "NVS.WRITE"),
            TokenKind::NvsRead => write!(f, "NVS.READ"),
            TokenKind::MqttConnect => write!(f, "MQTT.CONNECT"),
            TokenKind::MqttDisconnect => write!(f, "MQTT.DISCONNECT"),
            TokenKind::MqttPublish => write!(f, "MQTT.PUBLISH"),
            TokenKind::MqttSubscribe => write!(f, "MQTT.SUBSCRIBE"),
            TokenKind::MqttReceive => write!(f, "MQTT.RECEIVE"),
            TokenKind::BleInit => write!(f, "BLE.INIT"),
            TokenKind::BleAdvertise => write!(f, "BLE.ADVERTISE"),
            TokenKind::BleScan => write!(f, "BLE.SCAN"),
            TokenKind::BleSend => write!(f, "BLE.SEND"),
            TokenKind::BleReceive => write!(f, "BLE.RECEIVE"),
            TokenKind::JsonGet => write!(f, "JSON.GET"),
            TokenKind::JsonSet => write!(f, "JSON.SET"),
            TokenKind::JsonCount => write!(f, "JSON.COUNT"),
            TokenKind::LedSetup => write!(f, "LED.SETUP"),
            TokenKind::LedSet => write!(f, "LED.SET"),
            TokenKind::LedShow => write!(f, "LED.SHOW"),
            TokenKind::LedClear => write!(f, "LED.CLEAR"),
            TokenKind::DeepSleep => write!(f, "DEEPSLEEP"),
            TokenKind::EspnowInit => write!(f, "ESPNOW.INIT"),
            TokenKind::EspnowSend => write!(f, "ESPNOW.SEND"),
            TokenKind::EspnowReceive => write!(f, "ESPNOW.RECEIVE"),
            TokenKind::Data => write!(f, "DATA"),
            TokenKind::Read => write!(f, "READ"),
            TokenKind::Restore => write!(f, "RESTORE"),
            TokenKind::On => write!(f, "ON"),
            TokenKind::Swap => write!(f, "SWAP"),
            TokenKind::Def => write!(f, "DEF"),
            TokenKind::Randomize => write!(f, "RANDOMIZE"),
            TokenKind::Using => write!(f, "USING"),
            TokenKind::Error => write!(f, "ERROR"),
            TokenKind::TouchRead => write!(f, "TOUCH.READ"),
            TokenKind::ServoAttach => write!(f, "SERVO.ATTACH"),
            TokenKind::ServoWrite => write!(f, "SERVO.WRITE"),
            TokenKind::Tone => write!(f, "TONE"),
            TokenKind::IrqAttach => write!(f, "IRQ.ATTACH"),
            TokenKind::IrqDetach => write!(f, "IRQ.DETACH"),
            TokenKind::TempRead => write!(f, "TEMP.READ"),
            TokenKind::OtaUpdate => write!(f, "OTA.UPDATE"),
            TokenKind::OledInit => write!(f, "OLED.INIT"),
            TokenKind::OledPrint => write!(f, "OLED.PRINT"),
            TokenKind::OledPixel => write!(f, "OLED.PIXEL"),
            TokenKind::OledLine => write!(f, "OLED.LINE"),
            TokenKind::OledClear => write!(f, "OLED.CLEAR"),
            TokenKind::OledShow => write!(f, "OLED.SHOW"),
            TokenKind::LcdInit => write!(f, "LCD.INIT"),
            TokenKind::LcdPrint => write!(f, "LCD.PRINT"),
            TokenKind::LcdClear => write!(f, "LCD.CLEAR"),
            TokenKind::LcdPos => write!(f, "LCD.POS"),
            TokenKind::UdpInit => write!(f, "UDP.INIT"),
            TokenKind::UdpSend => write!(f, "UDP.SEND"),
            TokenKind::UdpReceive => write!(f, "UDP.RECEIVE"),
            TokenKind::NtpSync => write!(f, "NTP.SYNC"),
            TokenKind::NtpTime => write!(f, "NTP.TIME$"),
            TokenKind::NtpEpoch => write!(f, "NTP.EPOCH"),
            TokenKind::FileOpen => write!(f, "FILE.OPEN"),
            TokenKind::FileWrite => write!(f, "FILE.WRITE"),
            TokenKind::FileReadStr => write!(f, "FILE.READ$"),
            TokenKind::FileClose => write!(f, "FILE.CLOSE"),
            TokenKind::FileDelete => write!(f, "FILE.DELETE"),
            TokenKind::FileExists => write!(f, "FILE.EXISTS"),
            TokenKind::WsConnect => write!(f, "WS.CONNECT"),
            TokenKind::WsSend => write!(f, "WS.SEND"),
            TokenKind::WsReceiveStr => write!(f, "WS.RECEIVE$"),
            TokenKind::WsClose => write!(f, "WS.CLOSE"),
            TokenKind::TcpListen => write!(f, "TCP.LISTEN"),
            TokenKind::TcpAccept => write!(f, "TCP.ACCEPT"),
            TokenKind::TcpSend => write!(f, "TCP.SEND"),
            TokenKind::TcpReceiveStr => write!(f, "TCP.RECEIVE$"),
            TokenKind::TcpClose => write!(f, "TCP.CLOSE"),
            TokenKind::WdtEnable => write!(f, "WDT.ENABLE"),
            TokenKind::WdtFeed => write!(f, "WDT.FEED"),
            TokenKind::WdtDisable => write!(f, "WDT.DISABLE"),
            TokenKind::HttpsGet => write!(f, "HTTPS.GET$"),
            TokenKind::HttpsPost => write!(f, "HTTPS.POST$"),
            TokenKind::I2sInit => write!(f, "I2S.INIT"),
            TokenKind::I2sWrite => write!(f, "I2S.WRITE"),
            TokenKind::I2sStop => write!(f, "I2S.STOP"),
            TokenKind::Assert => write!(f, "ASSERT"),
            TokenKind::Enum => write!(f, "ENUM"),
            TokenKind::Each => write!(f, "EACH"),
            TokenKind::In => write!(f, "IN"),
            TokenKind::Try => write!(f, "TRY"),
            TokenKind::Catch => write!(f, "CATCH"),
            TokenKind::Lambda => write!(f, "LAMBDA"),
            TokenKind::Task => write!(f, "TASK"),
            TokenKind::Machine => write!(f, "MACHINE"),
            TokenKind::Module => write!(f, "MODULE"),
            TokenKind::FatArrow => write!(f, "=>"),
            TokenKind::InterpolatedString(v) => write!(f, "$\"{v}\""),
            TokenKind::FloatLiteral(v) => write!(f, "{v}"),
            TokenKind::IntLiteral(v) => write!(f, "{v}"),
            TokenKind::StringLiteral(v) => write!(f, "\"{v}\""),
            TokenKind::StringIdent(v) => write!(f, "{v}"),
            TokenKind::IntIdent(v) => write!(f, "{v}"),
            TokenKind::LongIdent(v) => write!(f, "{v}"),
            TokenKind::SingleIdent(v) => write!(f, "{v}"),
            TokenKind::DoubleIdent(v) => write!(f, "{v}"),
            TokenKind::Ident(v) => write!(f, "{v}"),
            TokenKind::Plus => write!(f, "+"),
            TokenKind::Minus => write!(f, "-"),
            TokenKind::Star => write!(f, "*"),
            TokenKind::Slash => write!(f, "/"),
            TokenKind::Backslash => write!(f, "\\"),
            TokenKind::Caret => write!(f, "^"),
            TokenKind::Eq => write!(f, "="),
            TokenKind::Neq => write!(f, "<>"),
            TokenKind::Lt => write!(f, "<"),
            TokenKind::Gt => write!(f, ">"),
            TokenKind::Le => write!(f, "<="),
            TokenKind::Ge => write!(f, ">="),
            TokenKind::LParen => write!(f, "("),
            TokenKind::RParen => write!(f, ")"),
            TokenKind::Comma => write!(f, ","),
            TokenKind::Semicolon => write!(f, ";"),
            TokenKind::Colon => write!(f, ":"),
        }
    }
}

/// A token with its kind and source span.
#[derive(Debug, Clone, PartialEq)]
pub struct Token {
    pub kind: TokenKind,
    pub span: Span,
}

/// Tokenize source code into a Vec of Tokens.
/// Returns an error for any unrecognized characters.
pub fn tokenize(source: &str) -> Result<Vec<Token>, LexError> {
    let mut tokens = Vec::new();
    let mut lexer = TokenKind::lexer(source);
    while let Some(result) = lexer.next() {
        let span = Span::from(lexer.span());
        match result {
            Ok(kind) => tokens.push(Token { kind, span }),
            Err(()) => {
                return Err(LexError {
                    span,
                    message: format!(
                        "unexpected character: '{}'",
                        &source[span.start..span.end]
                    ),
                });
            }
        }
    }
    // Ensure stream ends with a newline for parser convenience
    tokens.push(Token {
        kind: TokenKind::Newline,
        span: Span::new(source.len(), source.len()),
    });
    Ok(tokens)
}

#[derive(Debug, Clone)]
pub struct LexError {
    pub span: Span,
    pub message: String,
}

impl std::fmt::Display for LexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "lex error at {:?}: {}", self.span, self.message)
    }
}

impl std::error::Error for LexError {}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_qbasic_keywords() {
        let tokens = tokenize("PRINT DIM AS INTEGER SUB FUNCTION").unwrap();
        let kinds: Vec<_> = tokens.iter().map(|t| &t.kind).collect();
        assert!(matches!(kinds[0], TokenKind::Print));
        assert!(matches!(kinds[1], TokenKind::Dim));
        assert!(matches!(kinds[2], TokenKind::As));
        assert!(matches!(kinds[3], TokenKind::IntegerType));
        assert!(matches!(kinds[4], TokenKind::Sub));
        assert!(matches!(kinds[5], TokenKind::Function));
    }

    #[test]
    fn test_case_insensitive() {
        let tokens = tokenize("print Print PRINT").unwrap();
        for tok in &tokens[..3] {
            assert!(matches!(tok.kind, TokenKind::Print));
        }
    }

    #[test]
    fn test_compound_keywords_as_pairs() {
        // Compound keywords are now emitted as separate tokens
        let tokens = tokenize("END IF\nEND SUB\nSELECT CASE\nEXIT FOR\nCASE ELSE").unwrap();
        let kinds: Vec<_> = tokens
            .iter()
            .filter(|t| !matches!(t.kind, TokenKind::Newline))
            .map(|t| &t.kind)
            .collect();
        // END IF → End, If
        assert!(matches!(kinds[0], TokenKind::End));
        assert!(matches!(kinds[1], TokenKind::If));
        // END SUB → End, Sub
        assert!(matches!(kinds[2], TokenKind::End));
        assert!(matches!(kinds[3], TokenKind::Sub));
        // SELECT CASE → Select, Case
        assert!(matches!(kinds[4], TokenKind::Select));
        assert!(matches!(kinds[5], TokenKind::Case));
        // EXIT FOR → Exit, For
        assert!(matches!(kinds[6], TokenKind::Exit));
        assert!(matches!(kinds[7], TokenKind::For));
        // CASE ELSE → Case, Else
        assert!(matches!(kinds[8], TokenKind::Case));
        assert!(matches!(kinds[9], TokenKind::Else));
    }

    #[test]
    fn test_literals() {
        let tokens = tokenize("42 3.14 \"hello\"").unwrap();
        assert!(matches!(tokens[0].kind, TokenKind::IntLiteral(42)));
        assert!(matches!(tokens[1].kind, TokenKind::FloatLiteral(v) if (v - 3.14).abs() < 0.01));
        assert!(matches!(&tokens[2].kind, TokenKind::StringLiteral(s) if s == "hello"));
    }

    #[test]
    fn test_identifiers_with_suffixes() {
        let tokens = tokenize("x name$ count% total& speed! ratio#").unwrap();
        assert!(matches!(&tokens[0].kind, TokenKind::Ident(s) if s == "X"));
        assert!(matches!(&tokens[1].kind, TokenKind::StringIdent(s) if s == "NAME$"));
        assert!(matches!(&tokens[2].kind, TokenKind::IntIdent(s) if s == "COUNT%"));
        assert!(matches!(&tokens[3].kind, TokenKind::LongIdent(s) if s == "TOTAL&"));
        assert!(matches!(&tokens[4].kind, TokenKind::SingleIdent(s) if s == "SPEED!"));
        assert!(matches!(&tokens[5].kind, TokenKind::DoubleIdent(s) if s == "RATIO#"));
    }

    #[test]
    fn test_operators() {
        let tokens = tokenize("+ - * / \\ = <> < > <= >=").unwrap();
        let kinds: Vec<_> = tokens.iter().map(|t| &t.kind).collect();
        assert!(matches!(kinds[0], TokenKind::Plus));
        assert!(matches!(kinds[1], TokenKind::Minus));
        assert!(matches!(kinds[2], TokenKind::Star));
        assert!(matches!(kinds[3], TokenKind::Slash));
        assert!(matches!(kinds[4], TokenKind::Backslash));
        assert!(matches!(kinds[5], TokenKind::Eq));
        assert!(matches!(kinds[6], TokenKind::Neq));
        assert!(matches!(kinds[7], TokenKind::Lt));
        assert!(matches!(kinds[8], TokenKind::Gt));
        assert!(matches!(kinds[9], TokenKind::Le));
        assert!(matches!(kinds[10], TokenKind::Ge));
    }

    #[test]
    fn test_hardware_keywords() {
        let tokens = tokenize("GPIO.SET GPIO.READ GPIO.MODE DELAY").unwrap();
        assert!(matches!(tokens[0].kind, TokenKind::GpioSet));
        assert!(matches!(tokens[1].kind, TokenKind::GpioRead));
        assert!(matches!(tokens[2].kind, TokenKind::GpioMode));
        assert!(matches!(tokens[3].kind, TokenKind::Delay));
    }

    #[test]
    fn test_comment_styles() {
        let tokens = tokenize("REM this is old style\n' this is QBASIC style\nPRINT").unwrap();
        assert!(matches!(tokens[0].kind, TokenKind::Rem));
        assert!(matches!(tokens[1].kind, TokenKind::Newline));
        assert!(matches!(tokens[2].kind, TokenKind::Comment));
        assert!(matches!(tokens[3].kind, TokenKind::Newline));
        assert!(matches!(tokens[4].kind, TokenKind::Print));
    }

    #[test]
    fn test_do_loop() {
        let tokens = tokenize("DO WHILE UNTIL LOOP").unwrap();
        assert!(matches!(tokens[0].kind, TokenKind::Do));
        assert!(matches!(tokens[1].kind, TokenKind::While));
        assert!(matches!(tokens[2].kind, TokenKind::Until));
        assert!(matches!(tokens[3].kind, TokenKind::Loop));
    }

    #[test]
    fn test_dim_as() {
        let tokens = tokenize("DIM x AS INTEGER").unwrap();
        assert!(matches!(tokens[0].kind, TokenKind::Dim));
        assert!(matches!(&tokens[1].kind, TokenKind::Ident(s) if s == "X"));
        assert!(matches!(tokens[2].kind, TokenKind::As));
        assert!(matches!(tokens[3].kind, TokenKind::IntegerType));
    }

    #[test]
    fn test_new_keywords() {
        let tokens = tokenize("TRY CATCH ASSERT ENUM EACH IN LAMBDA TASK MACHINE STATE MODULE").unwrap();
        assert!(matches!(tokens[0].kind, TokenKind::Try), "expected Try, got {:?}", tokens[0].kind);
        assert!(matches!(tokens[1].kind, TokenKind::Catch), "expected Catch, got {:?}", tokens[1].kind);
        assert!(matches!(tokens[2].kind, TokenKind::Assert), "expected Assert, got {:?}", tokens[2].kind);
        assert!(matches!(tokens[3].kind, TokenKind::Enum), "expected Enum, got {:?}", tokens[3].kind);
        assert!(matches!(tokens[4].kind, TokenKind::Each), "expected Each, got {:?}", tokens[4].kind);
        assert!(matches!(tokens[5].kind, TokenKind::In), "expected In, got {:?}", tokens[5].kind);
        assert!(matches!(tokens[6].kind, TokenKind::Lambda), "expected Lambda, got {:?}", tokens[6].kind);
        assert!(matches!(tokens[7].kind, TokenKind::Task), "expected Task, got {:?}", tokens[7].kind);
        assert!(matches!(tokens[8].kind, TokenKind::Machine), "expected Machine, got {:?}", tokens[8].kind);
        // STATE is a contextual keyword — tokenized as Ident("STATE")
        assert!(matches!(&tokens[9].kind, TokenKind::Ident(s) if s == "STATE"), "expected Ident(STATE), got {:?}", tokens[9].kind);
        assert!(matches!(tokens[10].kind, TokenKind::Module), "expected Module, got {:?}", tokens[10].kind);
    }
}
